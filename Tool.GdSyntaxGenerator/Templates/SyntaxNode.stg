delimiters "<", ">"

Begin(model, context) ::=<<
<writeFileHeader(context)>

using JetBrains.Annotations;
using Pharmatechnik.Language.Gd.Internal;

namespace <model.Namespace> {
   
    <writeAbstractSyntaxClasses(model.AbstractSlots)>
    <writeSyntaxClasses(model.Slots)>
}
>>

writeAbstractSyntaxClasses(abstractSlots) ::=<<
<abstractSlots:writeAbstractSyntaxClass(); separator="\r\n">  
>>

writeAbstractSyntaxClass(abstractSlot) ::=<<
public abstract partial class <abstractSlot.RuleName>Syntax: SyntaxNode {
    
    internal <abstractSlot.RuleName>Syntax(
        SyntaxTree syntaxTree, 
        SyntaxSlot slot, 
        SyntaxNode parent,
		int position)

        : base(syntaxTree: syntaxTree, 
               slot      : slot, 
               parent    : parent,
			   position  : position) {

    }

}

>>

writeSyntaxClasses(slots) ::=<<
<slots:writeSyntaxClass(); separator="\r\n">
  
>>

writeSyntaxClass(slot) ::=<<
public partial class <slot.RuleName>Syntax : <if(slot.BaseRuleName)><slot.BaseRuleName>Syntax<else>SyntaxNode<endif> {
    
    <writeSyntaxNodeFields(slot.SyntaxSlots)>

    internal <slot.RuleName>Syntax (
        SyntaxTree syntaxTree, 
        <slot.RuleName>SyntaxSlot slot, 
        SyntaxNode parent,
		int position)

        : base(syntaxTree: syntaxTree, 
               slot      : slot, 
               parent    : parent,
			   position  : position) {

    }
	
	<writeSlotProperties(slot.Slots)>

	<writeGetCachedSlotMethod(slot.Slots)>
	     
    internal new <slot.RuleName>SyntaxSlot Slot => (<slot.RuleName>SyntaxSlot) base.Slot;

}

>>

writeSlotProperties(slotModels) ::=<<
<slotModels:writeSlotProperty(); anchor, separator="\r\n">
>>

writeSlotProperty(slot) ::=<<
<if(slot.IsToken)><slot:writeTokenProperty()><else><slot:writeSyntaxProperty()><endif>
>>

writeTokenProperty(tokenSlotModel) ::=<<
public SyntaxToken <tokenSlotModel.Name>Token => Slot.<tokenSlotModel.Name>Token.Realize(SyntaxTree, this);
>>

writeSyntaxProperty(syntaxSlot)::=<<
<if(syntaxSlot.IsToN)><syntaxSlot:writeSyntaxPropertyToN()><else><syntaxSlot:writeSyntaxPropertyTo1()><endif>
>>

writeSyntaxPropertyTo1(syntaxSlot)::=<<
public <syntaxSlot.Name>Syntax <syntaxSlot.Name> => GetSyntaxNode(ref <syntaxSlot.FieldName>, Slot.<syntaxSlot.Name><syntaxSlot:pl()>, index: <syntaxSlot.SlotIndex>);
>>

writeSyntaxPropertyToN(syntaxSlot)::=<<
public SyntaxList\<<syntaxSlot.Name>Syntax> <syntaxSlot.Name><syntaxSlot:pl()> => GetSyntaxNode\<<syntaxSlot.Name>Syntax, <syntaxSlot.Name>SyntaxSlot>(ref <syntaxSlot.FieldName><syntaxSlot:pl()>, Slot.<syntaxSlot.Name><syntaxSlot:pl()>, index: <syntaxSlot.SlotIndex>);
>>

writeSyntaxNodeFields(syntaxSlots) ::=<<
<syntaxSlots:writeSyntaxNodeField(); separator="\r\n">
>>

writeSyntaxNodeField(syntaxSlot)::=<<
<syntaxFieldType(syntaxSlot)> <syntaxSlot.FieldName><syntaxSlot:pl()>;
>>

syntaxFieldType(syntaxSlot)::=<<
<if(syntaxSlot.IsToN)>SyntaxListNode<else><syntaxSlot.Name>Syntax<endif>
>>

pl(slotModel)::=<<
<if(slotModel.IsToN)>s<endif>
>>

// GetCachedSlot method 

writeGetCachedSlotMethod(slotModels) ::=<<

[CanBeNull]
public override SyntaxNode GetCachedSlot(int index) {
	switch(index) {
		<slotModels:writeGetCachedSlotCase(); anchor>
		default:
			return null;
	}
}
>>

writeGetCachedSlotCase(slotModel) ::=<<
<if(slotModel.IsSyntaxNode)>
case <slotModel.SlotIndex>:
	return <slotModel.FieldName><slotModel:pl()>;<endif>
>>